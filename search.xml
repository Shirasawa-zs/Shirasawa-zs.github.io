<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式第一次</title>
      <link href="/2022/09/25/java-she-ji-mo-shi/"/>
      <url>/2022/09/25/java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Java设计模式第一次学习"><a href="#Java设计模式第一次学习" class="headerlink" title="Java设计模式第一次学习"></a>Java设计模式第一次学习</h2><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>学习设计模式的前置条件</p><p>学习网站：</p><p>简单：<a href="https://www.jianshu.com/p/0cd7df8a7789">想要学习设计模式，你得先会看类图，一张图读懂ＵＭＬ - 简书 (jianshu.com)</a></p><p>其他：<a href="https://www.cnblogs.com/leafsunshin/p/11495300.html">UML基础教程 - leafsunshin - 博客园 (cnblogs.com)</a></p><p><img src="https://upload-images.jianshu.io/upload_images/2799767-3f16972d7b062110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp" alt="img"></p><p><strong>img</strong></p><p>了解这张图就可以了，主要分析六种关系，成对分析</p><blockquote><p>继承和实现</p></blockquote><p>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力</p><p>实现：指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系</p><blockquote><p>依赖和关联</p></blockquote><p>依赖：可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的,临时性的、非常弱的，可以简单理解</p><p>A，B两个类，A中的一个类的方法中的参数用到了B的类，关系联系很弱。</p><p>关联：他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量；</p><blockquote><p>聚合和组合</p></blockquote><p>聚合：聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如上图，一群大雁里有很多大雁的个体，大雁个体的死亡不影响大雁群。</p><p>组合：组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑，再比如上图，一只大雁有两个翅膀，大雁死了，翅膀这个类也不复存在。</p><h2 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h2><p><strong>开闭原则 OCP（Open Closed Principle）</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章摘要</title>
      <link href="/2022/09/24/za-tan/"/>
      <url>/2022/09/24/za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo一些有用的博客"><a href="#Hexo一些有用的博客" class="headerlink" title="Hexo一些有用的博客"></a>Hexo一些有用的博客</h1><h2 id="1-hexo手把手教你布置"><a href="#1-hexo手把手教你布置" class="headerlink" title="1.hexo手把手教你布置"></a>1.hexo手把手教你布置</h2><p><a href="https://www.zhihu.com/question/484633431/answer/2476184917?utm_campaign=&utm_medium=social&utm_oi=996162393482932224&utm_psn=1557492957648949248&utm_source=qq">(2 封私信 &#x2F; 12 条消息) 如何使用 Github Pages 和 Hexo 搭建个人博客？ - 知乎 (zhihu.com)</a></p><p>需要注意的是，现在github的默认分支是main，需要把_config.yaml的配置文件里的deploy的branch改成main</p><h2 id="2-设计模式视频"><a href="#2-设计模式视频" class="headerlink" title="2.设计模式视频"></a>2.设计模式视频</h2><p><a href="https://www.aliyundrive.com/s/SNMmtCV3twb">https://www.aliyundrive.com/s/SNMmtCV3twb</a></p><h2 id="3-设计模式网站"><a href="#3-设计模式网站" class="headerlink" title="3.设计模式网站"></a>3.设计模式网站</h2><p><a href="https://java-design-patterns.com/">https://java-design-patterns.com/</a><br><a href="https://refactoringguru.cn/design-patterns/iterator">https://refactoringguru.cn/design-patterns/iterator</a></p><h2 id="4-教程网站"><a href="#4-教程网站" class="headerlink" title="4.教程网站"></a>4.教程网站</h2><p><a href="https://www.baeldung.com/">https://www.baeldung.com/</a></p><h2 id="5-Hexo主题官方文档"><a href="#5-Hexo主题官方文档" class="headerlink" title="5.Hexo主题官方文档"></a>5.Hexo主题官方文档</h2><p><a href="https://caodong-street.github.io/2021/09/18/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">Hexo博客主题之hexo-theme-matery的介绍（转载于blinkfox） | Cao Dong (caodong-street.github.io)</a></p><h2 id="6-MarkDown官方文档"><a href="#6-MarkDown官方文档" class="headerlink" title="6.MarkDown官方文档"></a>6.MarkDown官方文档</h2><p><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 | Markdown 官方教程</a></p><h2 id="7-阿里云效"><a href="#7-阿里云效" class="headerlink" title="7.阿里云效"></a>7.阿里云效</h2><p><a href="https://help.aliyun.com/document_detail/423521.html">云效移动端快速入门 (aliyun.com)</a></p><h2 id="8-Git相关"><a href="#8-Git相关" class="headerlink" title="8.Git相关"></a>8.Git相关</h2><p><a href="https://blog.csdn.net/xu_song/article/details/94734095">(31条消息) 代码提交到Github的3种方法_xu_song的博客-CSDN博客_提交代码到github</a></p><p><a href="https://www.cnblogs.com/ye-feng-yu/p/11108696.html">将IDEA工程代码提交到Github - 代码梦工厂 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_20210426.html">Git实用技巧35招 - CherishTheYouth - 博客园 (cnblogs.com)</a></p><h2 id="9-搭建图床"><a href="#9-搭建图床" class="headerlink" title="9.搭建图床"></a>9.搭建图床</h2><p><a href="https://zhuanlan.zhihu.com/p/489236769">使用Github+picGo搭建图床，保姆级教程来了 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC和DI</title>
      <link href="/2022/09/23/ioc-he-di/"/>
      <url>/2022/09/23/ioc-he-di/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-和-DI"><a href="#IOC-和-DI" class="headerlink" title="IOC 和 DI"></a>IOC 和 DI</h2><p>学了很久的spring全家桶，但总感觉对这东西理解很模糊，没有系统总结过，学习总要输入和输出，感觉之前的学习总在被动输入，没有主动输出，总感觉少了点东西，今天以我理解的角度来看待spring，可能理解很片面，也可能哪天我成了大牛，重新看看这一篇博客，把他完善的更好</p><p>首先我们界定所有的软件思想都需要满足OCP原则，也就是我们软件工程需求的开闭原则，这是我们软件设计的一种思想，具体可以理解是</p><p><strong>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</strong></p><p><strong>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</strong></p><p><strong>只有依赖于抽象。实现开放封闭的核心思想就是对<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B?fromModule=lemma_inlink">抽象编程</a>，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以对修改就是封闭的；而通过<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1?fromModule=lemma_inlink">面向对象</a>的继承和对多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。</strong></p><p>以上加粗的字体来自百度百科，如果你想进一步了解，欢迎百度或者Google</p><p>同时我们需要有一个共识，我们所有的目的都是为了代码的更高稳定性，有了这个共识，我们就可以开始了。</p><h3 id="为什么需要IOC"><a href="#为什么需要IOC" class="headerlink" title="为什么需要IOC,"></a>为什么需要IOC,</h3><p>IOC本质上并不是一种技术，它是一种思想，也就是我们常说的控制反转，但我们为什么需要控制反转，使用控制反转有什么好处是我们需要去考虑的。我们举个栗子</p><p>我们首先以当前现象级的手游王者荣耀来说，他有很多英雄，假如你选择了一个英雄并选择放大招</p><h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><p>hero类</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiBai</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">R</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李白放大招了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DianWei</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">R</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;典韦放大招了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main类</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Main.getplayer();</span><br><span class="line">       <span class="keyword">if</span>(name.equals(<span class="string">&quot;Libai&quot;</span>))&#123;</span><br><span class="line">           <span class="type">LiBai</span> <span class="variable">liBai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LiBai</span>();</span><br><span class="line">           liBai.R();</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">&quot;DianWei&quot;</span>))&#123;</span><br><span class="line">           <span class="type">DianWei</span> <span class="variable">dianWei</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DianWei</span>();</span><br><span class="line">           dianWei.R();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getplayer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hero</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">return</span> hero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以思考，如果我们想要去加一个英雄，那么，我们就要if else 或者 switch case 里面去 new 一个对象，然后放大招，每一次我们都要去动里面的代码，有什么方法可以解决这个情况，此时有人说了：接口，没错，接口可以解决这个问题。其实这也引出了我们的标题，为什么要引入IOC</p><h3 id="如何实现IOC的原理"><a href="#如何实现IOC的原理" class="headerlink" title="如何实现IOC的原理"></a>如何实现IOC的原理</h3><h4 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h4><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hero</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">R</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LiBai</span> <span class="keyword">implements</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">R</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;李白放大招了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DianWei</span> <span class="keyword">implements</span> <span class="title class_">Hero</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">R</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;典韦放大招了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Main.getplayer();</span><br><span class="line">       <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(name.equals(<span class="string">&quot;Libai&quot;</span>))&#123;</span><br><span class="line">            hero = <span class="keyword">new</span> <span class="title class_">LiBai</span>();</span><br><span class="line"></span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">&quot;DianWei&quot;</span>))&#123;</span><br><span class="line">           hero = <span class="keyword">new</span> <span class="title class_">DianWei</span>();</span><br><span class="line">       &#125;</span><br><span class="line">       hero.R();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getplayer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">hero</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">return</span> hero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们看看第二版的代码，是不是优雅了很多，但是还是有问题，我们解决了方法调用的问题，让一个接口可以统一方法的调用，但是仍然困扰我们的是我们不能统一对象的实例化。</p><p>此时我们同样来借用大佬的一段总结</p><p><strong>1.单纯interface可以统一方法的调用，但是它不能统一对象的实例化</strong></p><p><strong>2.面向对象主要做两件事情:实例化对象调用方法(完成业务逻辑)</strong></p><p><strong>3．只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP</strong></p><p><strong>4.上面的这句话只是表象，实质是一段代码如果要保持稳定，就不应该负责对象的实例化</strong></p><p><strong>5.对象实例化是不可能消除的</strong></p><p><strong>6.把对象实例化的过程，转移到其他的代码片段里</strong></p><p>我们通过以上的总结可以思考如何解决对象实例化(new)的问题，可不可以把对象实例化放进以一个工厂里，等我们需要时工厂给我们加载，由此，我们想到了我们可以用工厂模式来尝试的解决。</p><p>工厂模式有三种</p><p>简单工厂模式</p><p>工厂模式</p><p>抽象工厂模式</p><p>如果有机会，看完设计模式，也会写一点东西记录一下</p><h4 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h4><p>Factory类</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FacotryHero</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Hero <span class="title function_">getHero</span> <span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(name.equals(<span class="string">&quot;Libai&quot;</span>))&#123;</span><br><span class="line">            hero = <span class="keyword">new</span> <span class="title class_">LiBai</span>();</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name.equals(<span class="string">&quot;DianWei&quot;</span>))&#123;</span><br><span class="line">            hero = <span class="keyword">new</span> <span class="title class_">DianWei</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main类</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Main.getplayer();</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> FacotryHero.getHero(name);</span><br><span class="line">        hero.R();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样我们的代码看起来就变成了稳定的</p><p>我们可以了解，Factory是不稳定的，Main类是稳定的，这时候有人说了，这不是骗人吗,把原来项目里的不稳定代码放进了Factory里就变成稳定的了? 实际上确实如此，我们可以这样想，我们代码的不稳定就是来自于我们需要new的对象，当我们需要创建对象就不可避免的去new对象，如果有一个代码可以帮我们把所有的不稳定隔离起来，也就是帮我们去new所有的对象并返回，那我们的主类代码就是稳定的满足ocp，当然还有一个问题FacotryHero.getHero这串代码本质上来说还是不稳定的，因为如果Factory里没有，我们还是要去动Factory里的代码，这就不满足ocp原则了，只有Factory足够的大，足够的完善，可以帮我们处理所有的请求，我们的代码才能实现真正意义上的稳定，是不是有点感觉了。</p><p>我们来聊聊不稳定，我们开发的意义实际上还是面向用户也业务编程，没有了用户，我们什么都不是，用户提出了一个需求，这个需求的解不是唯一的，这不为一的解才是我们代码不稳定的本质原因。就好比一个用户选择了亚瑟，另一个用户选择了李白，这两个不同的需求的变化导致了我们代码的不稳定，我们的工厂里有亚瑟，好的，我直接返回给你，没有李白，不好意思，你的工厂里要自己再去new一个，这就造成了代码的不稳定，总的来说表面上是我们代码的不稳定，实际上是用户需求的变化。这也是我们的面向对象编程，用户的每一个需求都是我们可能创建的对象。那有没有办法在用户提出需求的时候，就已经可以自动创建对象，实际上是有的。</p><h4 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h4><p>factory</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Hero <span class="title function_">GetHeroByReflect</span><span class="params">(String name)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">strname</span> <span class="operator">=</span> <span class="string">&quot;com.scy.test.Hero.&quot;</span> + name;</span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(strname);</span><br><span class="line">        <span class="comment">//cls.getDeclaredConstructor().newInstance();</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        <span class="keyword">return</span> (Hero) obj;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Main</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Main.getplayer();</span><br><span class="line">       <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> FacotryHero.GetHeroByReflect(name);</span><br><span class="line">       hero.R();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们通过用户的字符串输入实现用户自己创建对象并返回，<strong>工厂模式 + 反射</strong>在IOC里面有着大量的应用，但和我们有一定的区别，spring通过工厂模式和反射，当用户一个字符串注入时我们现在的代码每次都需要进行反射，但是spring可能将他放进缓存里，下一次再去创建直接从缓存里拿就行，但工厂模式+反射并不是IOC和DI</p><p>IOC是控制反转,DI是依赖注入，我们的工厂模式 + 反射仍然需要用户去输入字符串，容器去创建对象，是一个正常的思维模式，<strong>没有IOC精华的控制反转和依赖注入</strong></p><p>配置文件的变化违反OCP吗，配置文件可以理解是外部的输入，就如同我们的用户输入意义，是一种变化，它的改变不违法OCP原则</p><h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><p>抓住两个字 <strong>要</strong> 和 <strong>给</strong></p><p>原来的代码</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, InstantiationException, IllegalAccessException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Main.getplayer();</span><br><span class="line">       <span class="type">Hero</span> <span class="variable">hero</span> <span class="operator">=</span> FacotryHero.GetHeroByReflect(name);</span><br><span class="line">       hero.R();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们还是需要FactoryHero.get方法向容器去要这个对象，只有对象的创建，没有控制的反转</p><p>想要的代码</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IC ic;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想主动声明一个对象，容器就可以主动把对象返回给我们，而不是去申请。</p><h4 id="IOC-DI-DIP"><a href="#IOC-DI-DIP" class="headerlink" title="IOC DI DIP"></a>IOC DI DIP</h4><p><strong>DIP: Dependency Inversion Principle 依赖倒置</strong></p><p>了解三个概念</p><ul><li>高层模块不应该依赖底层模块，两者应该都依赖抽象 &#x2F;&#x2F;高层就是抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p><strong>DI</strong></p><p>依赖注入</p><ol><li>属性注入</li><li>构造器注入</li><li>等等</li></ol><p>前提：我们的容器里有所有的对象，演示</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Container</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> get <span class="title function_">Bean</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//1 构造器注入</span></span><br><span class="line">        <span class="type">IC</span> <span class="variable">ic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">C</span>();</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>(ic);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2 属性注入</span></span><br><span class="line">        <span class="type">A</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        a1.setIC(ic);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器的本质是装配对象，比如我们有A, B, C三个对象， C对象依赖了A对象，我们在实现A对象的时候完全不用去考虑C对象，因为我们是面向抽象编程，我们未来编程可能是C接口的实现类，可能是c1,c2,c3等等，我们设计的时候只需要考虑A对象就行了。至于装配的工作交给容器就行了。</p><p><strong>IOC</strong></p><p>IOC就是一种思想，很模糊，没有一个具体的界定.DI就是IOC的一个具体的实现。</p><p>比如还是上述的代码，如果我们不采用IOC的话</p><p>java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IC ic;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.c.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主控类是A，也可以理解是我们程序员，因为我们可以决定是否创建</p><p>当我们引入了IOC思想，主控类变成了容器，由容器来决定类的依赖注入和装配。</p><p>或者程序员负责生产类，产品经理或用户来负责使用，这还不是很理解，等对IOC有进一步的理解再说吧</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
