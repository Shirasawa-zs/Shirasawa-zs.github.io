<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot简介1</title>
      <link href="/2022/09/27/spring-he-springboot-jian-jie/"/>
      <url>/2022/09/27/spring-he-springboot-jian-jie/</url>
      
        <content type="html"><![CDATA[<h3 id="SpringBoot和Spring简介"><a href="#SpringBoot和Spring简介" class="headerlink" title="SpringBoot和Spring简介"></a>SpringBoot和Spring简介</h3><p><strong>注解学习：<a href="https://liayun.blog.csdn.net/article/details/115053350">(32条消息) 历时三个月，史上最详细的Spring注解驱动开发系列教程终于出炉了，给你全新震撼_李阿昀的博客-CSDN博客</a></strong></p><p><strong>csdn虽然很垃圾，但里面还是有大佬的…,垃圾堆里刨食</strong></p><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h5><p>java网页端的开发过程如下javaweb -&gt; ssm -&gt; springboot</p><p>其中ssm常规理解是spring + springMVC + Mybatis</p><p>本质上来说，springMVC是spring家族的一个模块，也就是人们常说的spring framework</p><p>而spring家族的集大成者springboot可以看作是spring framework的一种抽象实现</p><h5 id="2-为什么要用springboot"><a href="#2-为什么要用springboot" class="headerlink" title="2.为什么要用springboot"></a>2.为什么要用springboot</h5><p>springboot的重点之一就是<strong>自动配置</strong></p><p>在传统的SSM框架集成中，需要编写大量的XML配置文件，比如集成Mybatis时，需要编写mybatis_config.xml文件，在集成springmvc时，需要编写springmvc.xml文件，这些配置文件十分繁琐，还很容易出现错误，导致开发效率低。而Spring Boot采用约定大于配置的思想，将大量的spring配置文件集成到Spring Boot的内部，帮助开发人员自动配置各类XML文件，极大的简化了开发过程。<br>以上是大部分人对springboot配置的定义，实际上，我感觉，是程序员感觉配置类比xml文件好用，所以决定用配置类和注解</p><h5 id="3-IOC"><a href="#3-IOC" class="headerlink" title="3.IOC"></a>3.IOC</h5><p>IOC是满足OCP原则的</p><p>IOC是一种抽象的概念，java里面具体理解可以分为三个</p><p>1.创建容器</p><p>2.对象加入容器</p><p>3.注入</p><p>抽象理解的话就是老生常谈的问题</p><p>控制反转</p><p>作为开发者，我们只需要考虑把对象加入容器，然后注入我们所需要的对象就行了，作为设计IOC容器的人，他需要考虑的是灵活注入满足更灵活的OCP场景,这也是我们需要学习的。</p><h5 id="4-应用"><a href="#4-应用" class="headerlink" title="4.应用"></a>4.应用</h5><p><strong>简单应用：就两个注解就行</strong></p><p>@Component @Autowired</p><p>注入容器并取出</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Aki</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Aki R"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestControllerpublic class TestController &#123;    @Autowired    private Aki aki;    @RequestMapping(&quot;&#x2F;&quot;)    public void get()&#123;        aki.R();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更深入一点</p><p>@Component</p><p>@Controller</p><p>@Service</p><p>@Repository</p><p>@Configuration</p><p>前四个用来解决 组件&#x2F;类和忘了叫什么的new的问题，只不过所属层级不同</p><h5 id="5-注入相关"><a href="#5-注入相关" class="headerlink" title="5.注入相关"></a>5.注入相关</h5><p>IOC对象的实例化，注入时机都是在容器创建就完成的，可以用@lazy延迟实例化加载，不过如果一个类里面引用了其他对象，那么作为属性的对象的延迟加载无效。</p><p>@lazy一般不用，了解一下就行</p><p>三种注入方式</p><p>属性注入</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Autowired    private Aki aki;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>构造器注入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Aki</span> aki<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">public</span> <span class="token class-name">TestController</span><span class="token punctuation">(</span><span class="token class-name">Aki</span> aki<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>aki <span class="token operator">=</span> aki<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name"><span class="token namespace">aki<span class="token punctuation">.</span></span>R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>setter注入</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token class-name">Aki</span> aki<span class="token punctuation">;</span>   <span class="token annotation punctuation">@Autowired</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAki</span><span class="token punctuation">(</span><span class="token class-name">Aki</span> aki<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token keyword">this</span><span class="token punctuation">.</span>aki <span class="token operator">=</span> aki<span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span>   <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token class-name"><span class="token namespace">aki<span class="token punctuation">.</span></span>R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了代码的稳定性，我们可以引入抽象的概念</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public interface IHero &#123;    void R();&#125;-----------------------------------------------------@Componentpublic class Aki implements IHero&#123;    public Aki()&#123;        System.out.println(&quot;Aki ... constructor&quot;);    &#125;    public void R()&#123;        System.out.println(&quot;Aki R&quot;);    &#125;&#125;-----------------------------------------------------@Componentpublic class Niko implements IHero&#123;    public void R()&#123;        System.out.println(&quot;niko R&quot;);    &#125;&#125;------------------------------------------------------    @RestControllerpublic class TestController &#123;    @Autowired    private IHero aki;    @RequestMapping(&quot;&#x2F;&quot;)    public void get()&#123;        aki.R();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>满足DIP，高层的实现不依赖于底层,此时我们应该有个疑问，</p><p><strong>@Autowired</strong></p><p><strong>private IHero aki;</strong></p><p>如何实现自动装配</p><p>经过实验，可以得出以下结论</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">//默认bytypeIHero &lt; 1 error      = 1 注入默认存在的一个      > 1 不一定报错，先根据字段名进行匹配，没有找到就报错    //我们可以通过byname指定    @Autowired    @Qualifier(value = "字段名")<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时我们就该考虑更深层次的问题，如果我们新增多个类，如何减少变化带来的影响，来保持我们代码的稳定性，也为了满足ocp原则</p><ul><li>制造一个interface,多个类实现这个interface</li></ul><p>设计模式的策略模式</p><ul><li>一个类的属性去解决变化，用配置文件去解决，不过还是建议实现接口，哪怕只有一个类</li></ul><p>栗子：MySQL的连接配置文件可以在application.yaml或者application.propertis，把所有的不稳定隔离到配置文件，我们又知道配置文件满足这个</p><p><strong>配置文件可以理解是外部的输入，就如同我们的用户输入意义，是一种变化，它的改变不违法OCP原则</strong>借此来解决。</p><h5 id="6-Configuration"><a href="#6-Configuration" class="headerlink" title="6.@Configuration"></a>6.@Configuration</h5><p>简单的理解，@Configuration是为了解决原来IOC容器无法对属性进行赋值的问题，它的角色更像是原来xml文件的作用，在springboot2还是3引入了这一概念</p><p>栗子</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">IHero</span> <span class="token function">createWolf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Wolf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Wolf</span> <span class="token keyword">implements</span> <span class="token class-name">IHero</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token class-name">Wolf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"wolf ... constructor"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"wolf R"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@RestControllerpublic class TestController &#123;    @Autowired    private IHero Wolf;    @RequestMapping(&quot;&#x2F;&quot;)    public void get()&#123;        Wolf.R();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述操作，我们实现了在@Configuration实现了bean的注入</p><p>接下来需要了解这个注解和xml，我们需要解决以下几个问题</p><p><strong>我们要明白为什么需要spring的配置？</strong></p><p>因为变化的出现，我们需要去隔离这些变化带给我们程序的不稳定，所以我们需要把所有的不稳定放到配置文件中，配置文件属于外部输入，也是一种变化，不影响OCP法则</p><blockquote><p>还有为什么隔离到配置文件</p></blockquote><p>1.配置文件的集中性</p><p>2.业务逻辑的无关性，只需要关心配置就行</p><p><strong>@Configuration是否违反了OCP</strong></p><p>这个问题聚焦到@Configruation是否属于配置，这要从思想上来解决这个问题</p><p><strong>是</strong>：对比其他配置文件，它虽然是以.java文件的后缀，但不否认的是他仍然是一个配置文件，配置文件的定义不应该以后缀为鉴别条件</p><p><strong>否</strong>：相较于其他配置文件的简洁性，类似于SpringBoot的application,@Confiruation好像太过繁琐</p><blockquote><p>实现自动配置(有缺陷）</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IConnect</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Mysql implements IConnect&#123;    private String ip &#x3D; &quot;192.168.0.1&quot;;    private String root &#x3D; &quot;999&quot;;    public Mysql() &#123;    &#125;    public void connect()&#123;        System.out.println(this.ip + &quot;   &quot; + this.root);    &#125;    public Mysql(String ip, String root) &#123;        this.ip &#x3D; ip;        this.root &#x3D; root;    &#125;    @Override    public String toString() &#123;        return &quot;Mysql&#123;&quot; +                &quot;ip&#x3D;&#39;&quot; + ip + &#39;\&#39;&#39; +                &quot;, root&#x3D;&#39;&quot; + root + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;    public String getIp() &#123;        return ip;    &#125;    public void setIp(String ip) &#123;        this.ip &#x3D; ip;    &#125;    public String getRoot() &#123;        return root;    &#125;    public void setRoot(String root) &#123;        this.root &#x3D; root;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Connect</span> <span class="token punctuation">&#123;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;mysql.ip&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> ip<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"$&#123;mysql.port&#125;"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> root<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">IConnect</span> <span class="token function">mysql</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Mysql</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>ip<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">mysql.ip&#x3D;192.102.2.3mysql.port&#x3D;9999<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://cdn.jsdelivr.net/gh/Shirasawa-zs/BlogImage@main/img/20220927232106.png"></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式前瞻</title>
      <link href="/2022/09/25/java-she-ji-mo-shi/"/>
      <url>/2022/09/25/java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Java设计模式第一次学习"><a href="#Java设计模式第一次学习" class="headerlink" title="Java设计模式第一次学习"></a>Java设计模式第一次学习</h2><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>学习设计模式的前置条件</p><p>学习网站：</p><p>简单：<a href="https://www.jianshu.com/p/0cd7df8a7789">想要学习设计模式，你得先会看类图，一张图读懂ＵＭＬ - 简书 (jianshu.com)</a></p><p>其他：<a href="https://www.cnblogs.com/leafsunshin/p/11495300.html">UML基础教程 - leafsunshin - 博客园 (cnblogs.com)</a></p><p><img src="https://upload-images.jianshu.io/upload_images/2799767-3f16972d7b062110.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/747/format/webp" alt="img"></p><p><strong>img</strong></p><p>了解这张图就可以了，主要分析六种关系，成对分析</p><blockquote><p>继承和实现</p></blockquote><p>继承：指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力</p><p>实现：指的是一个class类实现interface接口（可以是多个）的功能；实现是类与接口之间最常见的关系</p><blockquote><p>依赖和关联</p></blockquote><p>依赖：可以简单的理解，就是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的,临时性的、非常弱的，可以简单理解</p><p>A，B两个类，A中的一个类的方法中的参数用到了B的类，关系联系很弱。</p><p>关联：他体现的是两个类、或者类与接口之间语义级别的一种强依赖关系。这种关系比依赖更强、不存在依赖关系的偶然性、关系也不是临时性的，一般是长期性的，而且双方的关系一般是平等的、关联可以是单向、双向的；表现在代码层面，为被关联类B以类属性的形式出现在关联类A中，也可能是关联类A引用了一个类型为被关联类B的全局变量；</p><blockquote><p>聚合和组合</p></blockquote><p>聚合：聚合是关联关系的一种特例，他体现的是整体与部分、拥有的关系，即has-a的关系，此时整体与部分之间是可分离的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。比如上图，一群大雁里有很多大雁的个体，大雁个体的死亡不影响大雁群。</p><p>组合：组合也是关联关系的一种特例，他体现的是一种contains-a的关系，这种关系比聚合更强，也称为强聚合；他同样体现整体与部分间的关系，但此时整体与部分是不可分的，整体的生命周期结束也就意味着部分的生命周期结束；比如你和你的大脑，再比如上图，一只大雁有两个翅膀，大雁死了，翅膀这个类也不复存在。</p><h2 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h2><p>相关代码在我的github仓库</p><p><a href="https://www.jianshu.com/p/613d182ffceb">软件设计的七大原则 - 简书 (jianshu.com)</a></p><p>开闭原则</p><p>开闭原则（Open-Closed Principle, OCP）是指一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。所谓的开闭，也正是对扩展和修改两个行为的一个原则。强调的是用抽象构建框架，用实现扩展细节。可以提高软件系统的可复用性及可维护性。开<br>闭原则，是面向对象设计中最基础的设计原则。它指导我们如何建立稳定灵活的系统，例如：我们版本更新，我尽可能不修改源代码，但是可以增加新功能。</p><p>依赖倒置原则</p><p>依赖倒置原则（Dependence Inversion Principle,DIP）是指设计代码结构时，高层模块不应该依赖底层模块，二者都应该依赖其抽象。抽象不应该依赖细节；细节应该依赖抽象。通过依赖倒置，可以减少类与类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，并能够降低修改程序所造成的风险。</p><p>单一职责原则</p><p>单一职责（Simple Responsibility Pinciple，SRP）是指不要存在多于一个导致类变更的原因。假设我们有一个 Class 负责两个职责，一旦发生需求变更，修改其中一个职责的逻辑代码，有可能会导致另一个职责的功能发生故障。这样一来，这个 Class 存在两个导致类变更的原因。如何解决这个问题呢？我们就要给两个职责分别用两个 Class 来实现，进行解耦。后期需求变更维护互不影响。这样的设计，可以降低类的复杂度，提高类的可 读 性 ， 提 高 系 统 的 可 维 护 性 ， 降 低 变 更 引 起 的 风 险 。 总 体 来 说 就 是 一 个Class&#x2F;Interface&#x2F;Method 只负责一项职责。</p><p>接口隔离原则</p><p>接口隔离原则（Interface Segregation Principle, ISP）是指用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。这个原则指导我们在设计接口时应当注意一下几点：<br>1、一个类对一类的依赖应该建立在最小的接口之上。<br>2、建立单一接口，不要建立庞大臃肿的接口。<br>3、尽量细化接口，接口中的方法尽量少（不是越少越好，一定要适度）。<br>接口隔离原则符合我们常说的高内聚低耦合的设计思想，从而使得类具有很好的可读性、可扩展性和可维护性。我们在设计接口的时候，要多花时间去思考，要考虑业务模型，包括以后有可能发生变更的地方还要做一些预判。</p><p>迪米特法则</p><p>迪米特原则（Law of Demeter LoD）是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则（Least Knowledge Principle,LKP），尽量降低类与类之间的耦合。迪米特原则主要强调只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为成员朋友类，而出现在方法体内部的类不属于朋友类。</p><p>里氏替换原则</p><p>里氏替换原则（Liskov Substitution Principle,LSP）是指如果对每一个类型为 T1 的对象 o1,都有类型为 T2 的对象 o2,使得以 T1 定义的所有程序 P 在所有的对象 o1 都替换成o2 时，程序 P 的行为没有发生变化，那么类型 T2 是类型 T1 的子类型。<br>定义看上去还是比较抽象，我们重新理解一下，可以理解为一个软件实体如果适用一个父类的话，那一定是适用于其子类，所有引用父类的地方必须能透明地使用其子类的对象，子类对象能够替换父类对象，而程序逻辑不变。根据这个理解，我们总结一下：<br>引申含义：子类可以扩展父类的功能，但不能改变父类原有的功能。<br>1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。<br>2、子类中可以增加自己特有的方法。<br>3、当子类的方法重载父类的方法时，方法的前置条件（即方法的输入&#x2F;入参）要比父类方法的输入参数更宽松。<br>4、当子类的方法实现父类的方法时（重写&#x2F;重载或实现抽象方法），方法的后置条件（即方法的输出&#x2F;返回值）要比父类更严格或相等。</p><p>使用里氏替换原则有以下优点：<br>1、约束继承泛滥，开闭原则的一种体现。<br>2、加强程序的健壮性，同时变更时也可以做到非常好的兼容性，提高程序的维护性、扩展性。降低需求变更时引入的风险。</p><p>合成复用原则</p><p>合成复用原则（Composite&#x2F;Aggregate Reuse Principle,CARP）是指尽量使用对象组合(has-a)&#x2F;聚合(contanis-a)，而不是继承关系达到软件复用的目的。可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少。<br>继承我们叫做白箱复用，相当于把所有的实现细节暴露给子类。组合&#x2F;聚合也称之为黑箱复用，对类以外的对象是无法获取到实现细节的。要根据具体的业务场景来做代码设计，其实也都需要遵循 OOP 模型。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文章摘要</title>
      <link href="/2022/09/24/za-tan/"/>
      <url>/2022/09/24/za-tan/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo一些有用的博客"><a href="#Hexo一些有用的博客" class="headerlink" title="Hexo一些有用的博客"></a>Hexo一些有用的博客</h1><h2 id="1-hexo手把手教你布置"><a href="#1-hexo手把手教你布置" class="headerlink" title="1.hexo手把手教你布置"></a>1.hexo手把手教你布置</h2><p><a href="https://www.zhihu.com/question/484633431/answer/2476184917?utm_campaign=&utm_medium=social&utm_oi=996162393482932224&utm_psn=1557492957648949248&utm_source=qq">(2 封私信 &#x2F; 12 条消息) 如何使用 Github Pages 和 Hexo 搭建个人博客？ - 知乎 (zhihu.com)</a></p><p>需要注意的是，现在github的默认分支是main，需要把_config.yaml的配置文件里的deploy的branch改成main</p><h2 id="2-设计模式视频"><a href="#2-设计模式视频" class="headerlink" title="2.设计模式视频"></a>2.设计模式视频</h2><p><a href="https://www.aliyundrive.com/s/SNMmtCV3twb">https://www.aliyundrive.com/s/SNMmtCV3twb</a></p><h2 id="3-设计模式网站"><a href="#3-设计模式网站" class="headerlink" title="3.设计模式网站"></a>3.设计模式网站</h2><p><a href="https://java-design-patterns.com/">https://java-design-patterns.com/</a><br><a href="https://refactoringguru.cn/design-patterns/iterator">https://refactoringguru.cn/design-patterns/iterator</a></p><h2 id="4-教程网站"><a href="#4-教程网站" class="headerlink" title="4.教程网站"></a>4.教程网站</h2><p><a href="https://www.baeldung.com/">https://www.baeldung.com/</a></p><h2 id="5-Hexo主题官方文档"><a href="#5-Hexo主题官方文档" class="headerlink" title="5.Hexo主题官方文档"></a>5.Hexo主题官方文档</h2><p><a href="https://caodong-street.github.io/2021/09/18/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/">Hexo博客主题之hexo-theme-matery的介绍（转载于blinkfox） | Cao Dong (caodong-street.github.io)</a></p><h2 id="6-MarkDown官方文档"><a href="#6-MarkDown官方文档" class="headerlink" title="6.MarkDown官方文档"></a>6.MarkDown官方文档</h2><p><a href="https://markdown.com.cn/basic-syntax/">Markdown 基本语法 | Markdown 官方教程</a></p><h2 id="7-阿里云效"><a href="#7-阿里云效" class="headerlink" title="7.阿里云效"></a>7.阿里云效</h2><p><a href="https://help.aliyun.com/document_detail/423521.html">云效移动端快速入门 (aliyun.com)</a></p><h2 id="8-Git相关"><a href="#8-Git相关" class="headerlink" title="8.Git相关"></a>8.Git相关</h2><p><a href="https://blog.csdn.net/xu_song/article/details/94734095">(31条消息) 代码提交到Github的3种方法_xu_song的博客-CSDN博客_提交代码到github</a></p><p><a href="https://www.cnblogs.com/ye-feng-yu/p/11108696.html">将IDEA工程代码提交到Github - 代码梦工厂 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/CherishTheYouth/p/CherishTheYouth_20210426.html">Git实用技巧35招 - CherishTheYouth - 博客园 (cnblogs.com)</a></p><h2 id="9-搭建图床"><a href="#9-搭建图床" class="headerlink" title="9.搭建图床"></a>9.搭建图床</h2><p><a href="https://zhuanlan.zhihu.com/p/489236769">使用Github+picGo搭建图床，保姆级教程来了 - 知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOC和DI</title>
      <link href="/2022/09/23/ioc-he-di/"/>
      <url>/2022/09/23/ioc-he-di/</url>
      
        <content type="html"><![CDATA[<h2 id="IOC-和-DI"><a href="#IOC-和-DI" class="headerlink" title="IOC 和 DI"></a>IOC 和 DI</h2><p>学了很久的spring全家桶，但总感觉对这东西理解很模糊，没有系统总结过，学习总要输入和输出，感觉之前的学习总在被动输入，没有主动输出，总感觉少了点东西，今天以我理解的角度来看待spring，可能理解很片面，也可能哪天我成了大牛，重新看看这一篇博客，把他完善的更好</p><p>首先我们界定所有的软件思想都需要满足OCP原则，也就是我们软件工程需求的开闭原则，这是我们软件设计的一种思想，具体可以理解是</p><p><strong>对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</strong></p><p><strong>对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。</strong></p><p><strong>只有依赖于抽象。实现开放封闭的核心思想就是对<a href="https://baike.baidu.com/item/%E6%8A%BD%E8%B1%A1%E7%BC%96%E7%A8%8B?fromModule=lemma_inlink">抽象编程</a>，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以对修改就是封闭的；而通过<a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1?fromModule=lemma_inlink">面向对象</a>的继承和对多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。</strong></p><p>以上加粗的字体来自百度百科，如果你想进一步了解，欢迎百度或者Google</p><p>同时我们需要有一个共识，我们所有的目的都是为了代码的更高稳定性，有了这个共识，我们就可以开始了。</p><h3 id="为什么需要IOC"><a href="#为什么需要IOC" class="headerlink" title="为什么需要IOC,"></a>为什么需要IOC,</h3><p>IOC本质上并不是一种技术，它是一种思想，也就是我们常说的控制反转，但我们为什么需要控制反转，使用控制反转有什么好处是我们需要去考虑的。我们举个栗子</p><p>我们首先以当前现象级的手游王者荣耀来说，他有很多英雄，假如你选择了一个英雄并选择放大招</p><h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><p>hero类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LiBai</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"李白放大招了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DianWei</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"典韦放大招了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Main类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Main &#123;    public static void main(String[] args) &#123;       String name &#x3D; Main.getplayer();       if(name.equals(&quot;Libai&quot;))&#123;           LiBai liBai &#x3D; new LiBai();           liBai.R();       &#125;else if(name.equals(&quot;DianWei&quot;))&#123;           DianWei dianWei &#x3D; new DianWei();           dianWei.R();       &#125;    &#125;    private static String getplayer()&#123;        Scanner scanner &#x3D; new Scanner(System.in);        String hero &#x3D; scanner.nextLine();        return hero;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h4><p>java类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Hero</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LiBai</span> <span class="token keyword">implements</span> <span class="token class-name">Hero</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"李白放大招了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DianWei</span> <span class="token keyword">implements</span> <span class="token class-name">Hero</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"典韦放大招了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Main类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class Main &#123;    public static void main(String[] args) &#123;       String name &#x3D; Main.getplayer();       Hero hero &#x3D; null;       if(name.equals(&quot;Libai&quot;))&#123;            hero &#x3D; new LiBai();       &#125;else if(name.equals(&quot;DianWei&quot;))&#123;           hero &#x3D; new DianWei();       &#125;       hero.R();    &#125;    private static String getplayer()&#123;        Scanner scanner &#x3D; new Scanner(System.in);        String hero &#x3D; scanner.nextLine();        return hero;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时，我们可以思考，如果我们想要去加一个英雄，那么，我们就要if else 或者 switch case 里面去 new 一个对象，然后放大招，每一次我们都要去动里面的代码，有什么方法可以解决这个情况，此时有人说了：接口，没错，接口可以解决这个问题。其实这也引出了我们的标题，为什么要引入IOC</p><h3 id="如何实现IOC的原理"><a href="#如何实现IOC的原理" class="headerlink" title="如何实现IOC的原理"></a>如何实现IOC的原理</h3><p>让我们看看第二版的代码，是不是优雅了很多，但是还是有问题，我们解决了方法调用的问题，让一个接口可以统一方法的调用，但是仍然困扰我们的是我们不能统一对象的实例化。</p><p>此时我们同样来借用大佬的一段总结</p><p><strong>1.单纯interface可以统一方法的调用，但是它不能统一对象的实例化</strong></p><p><strong>2.面向对象主要做两件事情:实例化对象调用方法(完成业务逻辑)</strong></p><p><strong>3．只有一段代码中没有new的出现，才能保持代码的相对稳定，才能逐步实现OCP</strong></p><p><strong>4.上面的这句话只是表象，实质是一段代码如果要保持稳定，就不应该负责对象的实例化</strong></p><p><strong>5.对象实例化是不可能消除的</strong></p><p><strong>6.把对象实例化的过程，转移到其他的代码片段里</strong></p><p>我们通过以上的总结可以思考如何解决对象实例化(new)的问题，可不可以把对象实例化放进以一个工厂里，等我们需要时工厂给我们加载，由此，我们想到了我们可以用工厂模式来尝试的解决。</p><p>工厂模式有三种</p><p>简单工厂模式</p><p>工厂模式</p><p>抽象工厂模式</p><p>如果有机会，看完设计模式，也会写一点东西记录一下</p><p>如何实现IOC的原理</p><h4 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h4><p>Factory类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FacotryHero</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Hero</span> getHero <span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"Libai"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            hero <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LiBai</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"DianWei"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            hero <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DianWei</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">return</span> hero<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Main类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token function">getplayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token class-name">FacotryHero</span><span class="token punctuation">.</span><span class="token function">getHero</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name"><span class="token namespace">hero<span class="token punctuation">.</span></span>R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们的代码看起来就变成了稳定的</p><p>我们可以了解，Factory是不稳定的，Main类是稳定的，这时候有人说了，这不是骗人吗,把原来项目里的不稳定代码放进了Factory里就变成稳定的了? 实际上确实如此，我们可以这样想，我们代码的不稳定就是来自于我们需要new的对象，当我们需要创建对象就不可避免的去new对象，如果有一个代码可以帮我们把所有的不稳定隔离起来，也就是帮我们去new所有的对象并返回，那我们的主类代码就是稳定的满足ocp，当然还有一个问题FacotryHero.getHero这串代码本质上来说还是不稳定的，因为如果Factory里没有，我们还是要去动Factory里的代码，这就不满足ocp原则了，只有Factory足够的大，足够的完善，可以帮我们处理所有的请求，我们的代码才能实现真正意义上的稳定，是不是有点感觉了。</p><p>我们来聊聊不稳定，我们开发的意义实际上还是面向用户也业务编程，没有了用户，我们什么都不是，用户提出了一个需求，这个需求的解不是唯一的，这不为一的解才是我们代码不稳定的本质原因。就好比一个用户选择了亚瑟，另一个用户选择了李白，这两个不同的需求的变化导致了我们代码的不稳定，我们的工厂里有亚瑟，好的，我直接返回给你，没有李白，不好意思，你的工厂里要自己再去new一个，这就造成了代码的不稳定，总的来说表面上是我们代码的不稳定，实际上是用户需求的变化。这也是我们的面向对象编程，用户的每一个需求都是我们可能创建的对象。那有没有办法在用户提出需求的时候，就已经可以自动创建对象，实际上是有的。</p><h4 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h4><p>factory</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Hero</span> <span class="token class-name">GetHeroByReflect</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span><span class="token punctuation">,</span> <span class="token class-name">ClassNotFoundException</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token class-name">String</span> strname <span class="token operator">=</span> <span class="token string">"com.scy.test.Hero."</span> <span class="token operator">+</span> name<span class="token punctuation">;</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">></span></span> cls <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>strname<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//cls.getDeclaredConstructor().newInstance();</span>        <span class="token class-name">Object</span> obj <span class="token operator">=</span> cls<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Hero</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Main</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token function">getplayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token class-name">FacotryHero<span class="token punctuation">.</span>GetHeroByReflect</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name"><span class="token namespace">hero<span class="token punctuation">.</span></span>R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过用户的字符串输入实现用户自己创建对象并返回，<strong>工厂模式 + 反射</strong>在IOC里面有着大量的应用，但和我们有一定的区别，spring通过工厂模式和反射，当用户一个字符串注入时我们现在的代码每次都需要进行反射，但是spring可能将他放进缓存里，下一次再去创建直接从缓存里拿就行，但工厂模式+反射并不是IOC和DI</p><p>IOC是控制反转,DI是依赖注入，我们的工厂模式 + 反射仍然需要用户去输入字符串，容器去创建对象，是一个正常的思维模式，<strong>没有IOC精华的控制反转和依赖注入</strong></p><p>配置文件的变化违反OCP吗，配置文件可以理解是外部的输入，就如同我们的用户输入意义，是一种变化，它的改变不违法OCP原则</p><h3 id="IOC和DI"><a href="#IOC和DI" class="headerlink" title="IOC和DI"></a>IOC和DI</h3><p>抓住两个字 <strong>要</strong> 和 <strong>给</strong></p><p>原来的代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">,</span> <span class="token class-name">InstantiationException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">&#123;</span>       <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token class-name">Main</span><span class="token punctuation">.</span><span class="token function">getplayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name">Hero</span> hero <span class="token operator">=</span> <span class="token class-name">FacotryHero<span class="token punctuation">.</span>GetHeroByReflect</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token class-name"><span class="token namespace">hero<span class="token punctuation">.</span></span>R</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是需要FactoryHero.get方法向容器去要这个对象，只有对象的创建，没有控制的反转</p><p>想要的代码</p><p>java</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">IC</span> ic<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们想主动声明一个对象，容器就可以主动把对象返回给我们，而不是去申请。</p><h4 id="IOC-DI-DIP"><a href="#IOC-DI-DIP" class="headerlink" title="IOC DI DIP"></a>IOC DI DIP</h4><p><strong>DIP: Dependency Inversion Principle 依赖倒置</strong></p><p>了解三个概念</p><ul><li>高层模块不应该依赖底层模块，两者应该都依赖抽象 &#x2F;&#x2F;高层就是抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p><strong>DI</strong></p><p>依赖注入</p><ol><li>属性注入</li><li>构造器注入</li><li>等等</li></ol><p>前提：我们的容器里有所有的对象，演示</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Container</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> get <span class="token class-name">Bean</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token comment">//1 构造器注入</span>        <span class="token class-name">IC</span> ic <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">A</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span>ic<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//2 属性注入</span>        <span class="token class-name">A</span> a1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        a1<span class="token punctuation">.</span><span class="token function">setIC</span><span class="token punctuation">(</span>ic<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>容器的本质是装配对象，比如我们有A, B, C三个对象， C对象依赖了A对象，我们在实现A对象的时候完全不用去考虑C对象，因为我们是面向抽象编程，我们未来编程可能是C接口的实现类，可能是c1,c2,c3等等，我们设计的时候只需要考虑A对象就行了。至于装配的工作交给容器就行了。</p><p><strong>IOC</strong></p><p>IOC就是一种思想，很模糊，没有一个具体的界定.DI就是IOC的一个具体的实现。</p><p>比如还是上述的代码，如果我们不采用IOC的话</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token keyword">private</span> <span class="token class-name">IC</span> ic<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>c<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>主控类是A，也可以理解是我们程序员，因为我们可以决定是否创建</p><p>当我们引入了IOC思想，主控类变成了容器，由容器来决定类的依赖注入和装配。</p><p>或者程序员负责生产类，产品经理或用户来负责使用，这还不是很理解，等对IOC有进一步的理解再说吧</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
